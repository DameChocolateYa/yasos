#*
 * yasos - a compiler for yasos language
 * Copyright (c) 2025 DameChocolateYa
 * Licensed under the BSD 3-Clause License.
 * See LICENSE file in the project root for full license text.
*#

import std;
import string;
import byte;
import mem;

struct File {
  fd: int; #- Descriptor
  buffer: &str;
  buf_size: int;
  pos: int;
  flags: int;
  is_open: int;
};

extern fun sys_open(path: str, flags: int, mode: int) -> int;
extern fun sys_close(fd: int) -> none;
extern fun sys_write(fd: int, data: str, bytes: int) -> int;
extern fun sys_read(fd: int, buf: &str, bytes: int) -> int;
extern fun sys_seek(fd: int, offset: int, whence: int) -> int;

declmod file;
fun open(path: str, flags: int) -> File {
  var f: File;
  f.fd = sys_open(path, flags, 420);
  if f.fd < 0 {
    std::perror("ERROR: could not open file (%s)\n", path);
    ret f;
  }
  f.buf_size = 4096;
  f.buffer = mem::alloc(f.buf_size);
  if f.buffer == nil {
    "ERROR: could not allocate file buffer\n";
    ret f;
  }
  var s: &str = f.buffer;
  *s = "";
  f.buffer = s;

  f.pos = 0;
  f.flags = flags;
  f.is_open = true;
  ret f;
} pub;

fun close(f: &File) -> none {
  var local_f: File;
  local_f = *f;

  if local_f.fd >= 0 {
    sys_close(local_f.fd);
  }

  if local_f.buffer != nil {
    mem::free(local_f.buffer);
  }
  local_f.buffer = nil;
  local_f.is_open = false;

  *f = local_f;
} pub;

fun isopen(f: File) -> int { #- No needed more since is_open field exists
  if f.buffer == nil {ret false;}
  ret true;
} pub;

fun write(f: &File, data: str) -> int {
  var local_f: File = *f;
  if local_f.fd < 0 {
    "ERROR: file not open\n";
    ret -1;
  }
  var bytes: int = string::len(data);
  var bytes_written: int = sys_write(local_f.fd, data, bytes);
  local_f.pos = bytes_written;

  *f = local_f;
  ret bytes_written;
} pub;

fun read(f: &File) -> str {
  var local_f: File = *f;
  if local_f.fd < 0 {
    "ERROR: file not open\n";
    ret "(null)";
  }
  if local_f.buffer == nil {
    "ERROR: file with a NULL buffer\n";
    ret "(null)";
  }
  var local_buf: &str = local_f.buffer;
  var bytes_read: int = sys_read(local_f.fd, local_buf, local_f.buf_size);
  if bytes_read <= 0 {
    ret "";
  } 
  var s: str = bytostr(local_buf, bytes_read); #- I dunno know why can't be a deref

  *f = local_f;

  ret s;
} pub;

fun seek(f: &File, pos: int, whence: int) -> none {
  var local_f: File = deref f;
  if local_f.fd < 0 {
    "ERROR: file not open\n";
    leave;
  }
  
  var new_pos: int = sys_seek(local_f.fd, pos, whence);
  if new_pos < 0 {
    "ERROR: seek failed";
    leave;
  }
  local_f.pos = new_pos;
  deref f = local_f;
} pub;

endmod;
